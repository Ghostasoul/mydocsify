### 1. MySQL的存储引擎是基于表还是基于数据库的？

基于表的。

### 2. MySQL中如何指定引擎？

1. 创建表时，可以通过ENGINE来指定存储引擎，在create语句最后加上“engine=存储引擎”即可；

   Create table table1(id int(11) primary key auto_increment) engine=MyISAM;

2. 修改表时，可以使用“alter table 表名 engine=存储引擎”；来指定存储引擎。

   alter table table1 engine=InnoDB；

### 3. MySQL支持哪几种执行引擎，有什么区别？

MySQL是开源的，有以下几种存储引擎：

MyISAM、InnoDB、NDB、MEMORY、Archieve、Fedarated以及Maria等。

### 4. InnoDB和MyISAM有什么区别？

InnoDB和MyISAM是MySQL中比较常见的两个执行引擎，MySQL在5.5之前版本默认存储引擎是MyISAM，5.5之后版本默认存储引擎是InnoDB，MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用。

>* 如果应用需要高度的数据完整性和事务支持，那么InnoDB是更好的选择。所以频繁修改以及数据安全性的情况适合。
>* 如果应用主要是读取操作，或者需要高效的全文搜索功能，那么MyISAM可能更适合。

主要有以下区别：

* InnoDB支持事务，MyISAM不支持

* InnoDB是聚集索引，MyISAM是非聚集索引。MyISAM是采用了一种索引和数据分离的存储方式，InnoDB聚簇索引中的索引和数据在一起。

* InnoDB支持外键，MyISAM不支持。

* InnoDB最小的颗粒度是行锁，MyISAM最小的颗粒度是表锁。

* InnoDB不支持FULLTEXT类型的索引（5.6之前不支持全文索引）

* InnoDB中不保存表的行数，但是MyISAM只要简单的读出保存好的行数即可。

* 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是MyISAM表中可以和其他字段一起创建联合索引

* 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重新建表。

  ---

  

|          | InnoDB             | MyISAM  |
|:---------| :----------------- | :------ |
| **事务**   | 支持               | 不支持  |
| **外键**   | 支持               | 不支持  |
| **聚簇索引** | 支持               | 不支持  |
| **锁级别**  | 支持行级锁、表级锁 | 表级锁  |
| 行数保存     | 不支持             | 支持    |
| 清空方式     | 逐行删除           | 重建表  |
| 默认版本     | 5.5之后            | 5.5之后 |
| 全文索引     | 5.6以后支持        | 支持    |

### 5. **char和varchar的区别？**

char和varchar都是用于在数据库中存储字符串的数据类型。他们之间的主要区别在于存储空间的使用方式：

**char是一种定长的数据类型**，他的长度固定且在存储时会自动在结尾添加空格来将字符串填满指定的长度。char的长度范围时0～255.

varchar是一种可变长度的数据类型，他只会存储实际的字符串内容，不会填充空格。因此，在存储短字符串时，varchar可以节省空间。varchar的长度范围时0～65535。

varchar的优点时变长的字符串类型，兼容性更好；但同时也会带来一些问题，如使用varchar可能会产生内存碎片、varchar会额外需要1到2个字节存储长度信息、以及update语句可能会导致页分裂。==存储产品的描述，用户地址，用户名称等，这些都适合用varchar==。

char的优点时定长的字符串类型，减少内存碎片，并且无需额外的磁盘空间去存储长度信息。但是他的缺点时会删除列末尾的空格信息。==存储身份证号、存储订单号，存储国家编码、都适合用char==。

>char会在长度不足时，在后面补充空格，所以当要一个长度为10的char时，存一个“hello”，他存储的是“hello    ”，所以会丢失原来存储的空格信息。

### 6. MySQL5.X和8.X有什么区别？

### 7. 什么是数据库范式，为什么要反范式？

### 8. 为什么不建议使用多表join？

### 9. MySQL一条SQL语句的执行过程？

### 10. InnoDB支持那几种行格式？

### 11. 什么是数据库事务？

### 12. InnoDB的一次更新事务是怎么实现的？

### 13. **什么是脏读、幻读、不可重复读？**

### 14. **MySQL中的事实隔离级别？**

### 15. InnoDB如何解决脏读、不可重复读和幻读的？

### 16. MySQL的select * 会用到事务吗？

### 17. 为什么MySQL默认使用RR隔离级别？

### 18. 什么有的公司会把默认级别改为RC？

### 19. InnoDB的RR到底有没有解决幻读？

### 20. **如何理解MVCC？**

### 21. 当前读和快照读有什么区别？

### 22. **InnoDB的锁机制？**

### 23. MySQL的行级锁锁的是什么？

### 24. **什么是拍他锁和共享锁？**

### 25. 乐观锁和悲观锁如何实现？

### 26. InnoDB加索引，这个时候会锁表吗？

### 27. **InnoDB中的索引类型？**

### 28. 为什么使用B+树实现索引？

### 29. MySQL是如何保证唯一性的？

### 30. **什么是聚簇索引和非聚簇索引？**

### 31. **什么是回表，怎么减少回表的次数？**

### 32. **什么是索引覆盖、索引下推？**

### 33. **设计索引的时候有哪些原则？**

### 34. **什么是最左前缀匹配？为什么要遵守？**

### 35. **MySQL索引一定遵循最左前缀匹配吗？**

### 36. MySQL的主键一定是自增的吗？

### 37. uuid和自增id做主键哪个好？为什么？

### 38. order by是怎么实现的？

### 39. count(1)、count(*)、count(列名)的区别？

### 40. limit0,100和limit 10000000,100一样吗？

### 41. **binlog、redolog和undolog的区别？**

### 42. 用了索引还是很慢，可能是什么原因？

### 43. **SQL执计划分析的时候，要关注哪些信息？**

### 44. MySQL是否支持emoji表情存储，如果不支持，如何操作？

### 45. 如何优化一个大规模的数据库系统？

### 46. MySQL只操作一条记录，也会发生死锁吗？

### 47. **数据库死锁如何解决？**

### 48. 索引实效的问题如何排查？

### 49. **如何进行SQL调优？**

### 50. 慢SQL的问题如何排查？

### 51. MySQL主从复制的过程？

### 52. **什么是buffer pool？**

### 53. buffer pool的读写过程？

### 54. 什么是InnoDB的页分裂和页合并？

### 55. **MySQL中的like的模糊查询如何优化？**

### 56. **阿里的数据库能抗秒杀的原理？**

### 57. **一个查询语句的执行顺序是怎样的？**

### 58. on和where有什么区别？

### 59. 高并发情况下自增主键会不会重复？

### 60. 什么情况下会导致自增主键不连续？



