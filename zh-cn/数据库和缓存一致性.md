### 1. 问题来源

使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问MySQL等数据库。

不管是先写MySQL数据库，再删除Redis缓存，还是先删除缓存，再写库，都有可能出现数据不一致的情况。

![截屏2024-03-01 22.51.21](https://qcloudtest-1256407512.cos.ap-guangzhou.myqcloud.com/Pic%E6%88%AA%E5%B1%8F2024-06-22%2014.20.23.png)



### 2. 例子

* 先更新MySQL，再更新Redis

  如果更新Redis失败，可能仍然不一致。

* 先删除Redis缓存数据，再更新MySQL

  再次查询的时候再将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新MySQL，此时另外一个线程查询，那么就会把MySQL中的数据又更新到Redis中。

### 3. 解决方案

* 延时双删

  先删除Redis缓存数据，再更新MySQL，延迟几百秒再删除Redis缓存数据，这样就算在更新MySQL时，有其他线程读了MySQL，把老数据读到Redis中，那么也会被删除掉，从而把数据保持一致。

* 队列+重试机制

  针对第一个如果删除Redis失败的情况来看的，也就是如果删除失败了，那么把删除的key放到mq中，然后客户端消费再次进行删除操作。